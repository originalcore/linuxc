# mmap(文件映射)

[参考文章Linux的mmap内存映射机制解析](https://blog.csdn.net/zqixiao_09/article/details/51088478)

## mmap简介

- mmap把文件内容映射到一段内存上(准确说是虚拟内存上)
- 通过对这段内存的读取和修改,实现对文件的读取和修改
- 普通文件被映射到进程地址空间后,进程可以向访问普通内存一样对文件进行访问,不必再调用read/write等

## 文件映射优点

- 文件映射一方面给用户提供了一组措施,好似用户将文件映射到自己地址空间的某个部分,使用简单的内存访问指令读写文件
- 它也可以用于内核的基本组织模式,在这种模式种,内核将整个地址空间视为诸如文件之类的一组不同对象的映射

传统文件方法(read/write)
- 传统文件访问方式(open/read/write等)进行顺序或者随即的I/O.这种方式是非常低效的,每一次I/O操作都需要一次系统调用
- 另外如果若干个进程访问同一个文件,每个进程都要在自己的地址空间维护一个副本,浪费了内存空间

## 驱动中的mmap函数

- 设备驱动的mmap实现主要是将一个物理设备的可操作区域(设备空间)映射到一个进程的虚拟地址空间
- 这样就可以直接采用指针的方式像访问内存的方式访问设备
- 在驱动中的mmap实现主要是完成一件事,就是实际物理设备的操作区域到进程虚拟空间地址的映射过程
- 同时也需要保证这段映射的虚拟存储器区域不会被进程当做一般的空间使用,因此需要添加一系列的保护方式

```c
/* 主要是建立虚拟地址到物理地址的页表关系,其他的过程又内核自己完成 */
static int mem_mmap(struct file* filp,struct vm_area_struct *vma)
{
    /* 间接的控制设备 */
    struct mem_dev *dev = filp->private_data;

    /* 标记这段虚拟内存映射为IO区域,并阻止系统将该区域包含在进程的存放转存中 */
    vma->vm_flags |= VM_IO;

    /* 标记这段区域不能被换出 */
    vma->vm_flags |= VM_RESERVED;

    if(remap_pfn_range(vma,/* 虚拟内存区域 */
        vma->vm_start, /* 虚拟地址的起始地址 */
        virt_to_phys(dev->data)>>PAGE_SHIFT, /* 物理存储区的物理页号 */
		dev->size,    /* 映射区域大小 */
        vma->vm_page_prot /* 虚拟区域保护属性 */))
        return -EAGAIN;

    return 0;
}
```

两个关键的标志位

	vma->vm_flags |= VM_IO;
	vma->vm_flags |= VM_RESERVED;

两个保护机制就说明了被映射的这段区域具有映射IO的相似性,同时保证这段区域不能随便的换出

虚拟页和物理页建立联系
具体原理是虚拟页和物理页之间是以页表的方式关联起来
虚拟内存通常大于物理内存,在使用过程中虚拟页通过页表关联一切对应的物理页
当物理页不够时,会选择性的牺牲一些页,也就是将物理页与虚拟页之间切断,重现关联其他的虚拟页,保证物理内存够用

mmap的作用是映射文件描述符fd指定文件的 [off,off + len]区域至调用进程的[addr, addr + len]的内存区域

![mmap](./mmap.png)

[实例1](./mmap1.c)

[实例2](./mmap2.c)
